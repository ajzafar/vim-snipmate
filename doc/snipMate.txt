*SnipMate.txt*	Plugin for using TextMate-style snippets in Vim.

SnipMate				*snippet* *snippets* *SnipMate*

|SnipMate-introduction|	 Introduction
|SnipMate-usage|	 Usage
|SnipMate-syntax|	 Snippet syntax
|SnipMate-settings|	 Settings
|SnipMate-features|	 Features
|SnipMate-disadvantages| Disadvantages to TextMate
|SnipMate-contact|	 Contact
|SnipMate-license|	 License

For Vim version 7.0 or later.
This plugin only works if 'compatible' is not set.
{Vi does not have any of these features.}

==============================================================================
INTRODUCTION						*SnipMate-introduction*

SnipMate implements some of TextMate's snippets features in Vim. A
snippet is a piece of often-typed text that you can insert into your
document using a trigger word. Snippets can be simple |abbrevations| or more
complex templates with tab stops, placeholders, and mirrors.

Tab stops define where a field is. A placeholder specifies default text to use
for a tab stop. Mirrors reuse the text for a tab stop in multiple places.
|SnipMate-syntax|

For instance, in a C file, the "for" trigger could expand to: >

	for (i = 0; i < count; i++) {
		/* code */
	}

==============================================================================
USAGE							*SnipMate-usage*

SnipMate is fairly straightforward to use. Simply start editing a filetype for
which you have snippets, type a trigger, then push <Tab> to expand it. The
snippet will be placed in the buffer, and the cursor will be placed on the
first tab stop for text entry; any mirrors will be updated as text is entered.
At any point, <Tab> can be used to reach the next tab stop and <S-Tab> to jump
to the previous one.

Snippets need not use a unique trigger. Insert mode completion
(|ins-completion|) is started either when multiple snippets are found for the
trigger or when an incomplete trigger is entered. If there are no possible
matches, a tab is inserted. |i_Tab|

If one knows exactly which snippet one wants, "_1" can be appended to the
trigger to expand the first snippet with that trigger.

When a tab stop is placed inside a placeholder for an earlier tab stop,
editing the outer placeholder in any way will cause the inner tab stop to be
skipped.

==============================================================================

SYNTAX							*SnipMate-syntax*

							*g:snippets_dir*
Snippets are by default looked for any "snippets" directory in your
'runtimepath'. To change that location or add another one, set the
g:snippets_dir variable in your |.vimrc| to a comma-separated list of
preferred directories. Snippets are defined on a per-filetype basis. Snippets
for the "vim" filetype are read from: >

	snippets/vim.snippets
	snippets/vim/*.snippets

Snippets for multiple languages can be loaded either using the dotted
'filetype' syntax or an "extends" line in the snippets file. Either of the
following will load snippets for HTML, JavaScript, and CSS: >

	:set ft=html.javascript.css

or, in html.snippets with ft=html: >

	extends javascript,css

The syntax for snippets in *.snippets files is the following: >

	snippet trigger Optional description
		expanded text
		more expanded text

Triggers must follow the same rules as |abbreviations|.

Note that the first hard tab after the snippet trigger is required and not
expanded in the actual snippet. Snippets must be defined using hard tabs. They
can be expanded to spaces later if desired (see |SnipMate-indenting|).

"#" is used as a line-comment character in *.snippets files; however, they can
only be used outside of a snippet declaration. E.g.: >

	# this is a correct comment
	snippet trigger
		expanded text
	snippet another_trigger
		# this isn't a comment!
		expanded text

This should hopefully be obvious with the included syntax highlighting.

								*SnipMate-${#}*
Tab stops ~

A tab stop, specified by ${#} where # is a number, tells SnipMate where to
position the cursor next. The special tab stop ${0} denotes the last cursor
position; in its absence, the cursor is placed at the end of the snippet.

For example, to place the cursor first on the id of a <div> tag, allow
the user to press <tab> to go to the middle of it, and finally end after
</div>: >

	snippet div
		<div id="${1}">
			${2}
		</div>

<			*SnipMate-placeholders* *SnipMate-${#:}* *SnipMate-$#*
Placeholders ~

Placeholder text can be supplied using "${#:text}", where # is the number of
the tab stop. This text then can be copied throughout the snippet using "$#",
given # is the same number as used before. So, to make a C for loop: >

	snippet for
		for (${2:i}; $2 < ${1:count}; $1++) {
			${0:body}
		}

This will cause "count" to first be selected and change if the user starts
typing. When <tab> is pressed, the "i" in ${2}'s position will be selected;
all $2 mirrors will default to "i" and automatically be updated if the user
starts typing.
NOTE: "$#" syntax is used only for mirrors, not for tab stops as in TextMate

Mirrors can also be used within placeholders: >

	snippet opt
		<option value="${1:option}">${2:$1}</option>

Will, as usual, cause "option" to first be selected and update all the $1
mirrors if the user starts typing. Since one of these mirrors is inside of
${2}, this text will then be used as a placeholder for the next tab stop,
allowing the user to change it if he wishes.

Lastly tab stops can be used within a placeholder, making them optional: >

	snippet div
		<div${1: id="${2:name}"}>
			${0}
		</div>

To copy a value throughout a snippet without supplying default text, simply
use the "${#:}" construct without the text; e.g.: >

	snippet foo
		${1:}bar$1

<							*SnipMate-commands*
Interpolated Vim Script ~

Snippets can also contain Vim script expressions, which are passed to |eval()|
when the snippet is inserted. For example to insert the current date: >

	snippet date
		`strftime("%Y-%m-%d")`

For TextMate functionality, one can use the |system()| function.

Filename([{expr}] [, {defaultText}])	*SnipMate-filename* *Filename()*

Since the current filename is used often in snippets, a default function
has been defined for it in SnipMate, appropriately called Filename().

With no arguments, the default filename without an extension is returned;
the first argument specifies what to place before or after the filename,
and the second argument supplies the default text to be used if the file
has not been named. "$1" in the first argument is replaced with the filename;
if you only want the filename to be returned, the first argument can be left
blank. Examples: >

	snippet filename
		`Filename()`
	snippet filename_with_default
		`Filename('', 'name')`
	snippet filename_foo
		`filename('$1_foo')`

The first example returns the filename if it the file has been named, and an
empty string if it hasn't. The second returns the filename if it's been named,
and "name" if it hasn't. The third returns the filename followed by "_foo" if
it has been named, and an empty string if it hasn't.

==============================================================================
SETTINGS				*SnipMate-settings* *g:snips_author*

The g:snips_author string (similar to $TM_FULLNAME in TextMate) should be set
to your name; it can then be used in snippets to automatically add it. E.g.: >

 let g:snips_author = 'Hubert Farnsworth'
 snippet name
	`g:snips_author`
<
				*SnipMate-expandtab* *SnipMate-indenting*
If you would like your snippets to be expanded using spaces instead of tabs,
just enable 'expandtab' and set 'softtabstop' to your preferred amount of
spaces. If 'softtabstop' is not set, 'shiftwidth' is used instead.

==============================================================================
FEATURES						*SnipMate-features*

SnipMate has the following features among others:
  - The syntax of snippets is very similar to TextMate's, allowing
    easy conversion.
  - The position of the snippet is kept transparently (i.e. it does not use
    markers/placeholders written to the buffer), which allows you to escape
    out of an incomplete snippet, something particularly useful in Vim.
  - Mirrors in snippets are updated as-you-type.
  - Triggers can have multiple snippets
  - Tab stops can be out of order. For instance, in a do...while loop, the
    condition can be added before the code.
  - File-based snippets are supported.
  - <S-Tab> can now be used to jump tab stops in reverse order.

==============================================================================
DISADVANTAGES					*SnipMate-disadvantages*

SnipMate currently has the following disadvantages to TextMate's snippets:
    - Regex cannot be performed on mirrors, such as "${1/.*/\U&}"
    - Placeholders cannot span multiple lines.
    - Activating snippets in different scopes of the same file is
      not possible.

Perhaps some of these features will be added in a later release.

==============================================================================
CONTACT					*SnipMate-contact* *SnipMate-author*

SnipMate was originally created by Michael Sanders, who can be reached at:
 msanders42+snipmate <at> gmail <dot> com

Since SnipMate development has stalled, various people have taken up
development. Major contributors to this version include:

- Adnan Zafar
- Rok Garbas
- Marc Weber

For a full list of contributors, see the Git history. This fork is hosted on
GitHub at <https://github.com/ajzafar/vim-snipmate>.

==============================================================================
LICENSE							*SnipMate-license*

SnipMate is released under the MIT license:

Copyright 2009-2010 Michael Sanders. All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

The software is provided "as is", without warranty of any kind, express or
implied, including but not limited to the warranties of merchantability,
fitness for a particular purpose and noninfringement. In no event shall the
authors or copyright holders be liable for any claim, damages or other
liability, whether in an action of contract, tort or otherwise, arising from,
out of or in connection with the software or the use or other dealings in the
software.

==============================================================================

vim:tw=78:ts=8:ft=help:norl:
